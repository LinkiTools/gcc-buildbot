# -*- python -*-
# ex: set syntax=python:

from __future__ import print_function
from buildbot.plugins import *
from buildbot.schedulers.basic import AnyBranchScheduler
from buildbot.schedulers.timed import Nightly
from buildbot.schedulers.trysched import Try_Jobdir
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.process import factory
from buildbot.process.properties import WithProperties, Property
from buildbot.steps.shell import Compile
from buildbot.steps.shell import Configure
from buildbot.steps.shell import ShellCommand
from buildbot.steps.shell import SetPropertyFromCommand
from buildbot.steps.transfer import FileUpload
from buildbot.steps.source.svn import SVN
from buildbot.steps.worker import RemoveDirectory
from buildbot.changes.filter import ChangeFilter
from buildbot.changes.svnpoller import SVNPoller
from buildbot.buildslave import BuildSlave
#from buildbot.status.results import SUCCESS, WARNINGS, FAILURE, EXCEPTION
from buildbot.interfaces import IEmailLookup
from zope.interface import implements
#from lib.gcccommand import CopyOldGCCSumFile, GccCatSumfileCommand
#from gccgitdb import SaveGCCResults, get_builder_commit_id
#from racyanalyze import GCCAnalyzeRacyTests
from urllib.parse import quote

#from sumfiles import DejaResults, set_web_base
import os.path
import urllib
from json import load
import re

####################################
####################################
#### GCC BuildBot Configuration ####
####################################
####################################

###############################
#### General Configuration ####
###############################

# This is the dictionary that the buildmaster pays attention to. We
# also use a shorter alias to save typing.
c = BuildmasterConfig = {}

# # Base directory for the web server.  This is needed in order to
# # compare the test results.
# gcc_web_base = os.path.expanduser (os.path.join (basedir,
#                                                  'public_html',
#                                                  'results'))
# set_web_base (gcc_web_base)

GCC_MAIL_FROM = 'pmatos+gcc-buildbot@linki.tools'
GCC_MAIL_TO = 'gcc-buildbot+botmail@linki.tools'

# 'protocols' contains information about protocols which master will use for
# communicating with slaves.
c['protocols'] = {'pb': {'port': 16123}}

# Revision links to gcc svn browser
c['revlink'] = util.RevlinkMatch([r'svn://gcc.gnu.org/svn/gcc.*'],
                                 r'https://gcc.gnu.org/viewcvs/gcc?view=revision&revision=%s')

# Since we don't have enough slaves, lets merge all requests
c['mergeRequests'] = True

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

# RE representing which branches to track on the GCC repository
# Track trunk and release branches
branches_to_watch = re.compile ("(trunk|gcc-\d+\.\d+-branch)")

# Function which decides whether BRANCH should be used or not
def should_watch_branch (change):
    if change is None:
        branch = 'trunk'
    else:
        branch = change.asDict()['branch']
    if re.match (branches_to_watch, branch):
        return True
    else:
        return False

c['change_source'] = []
c['change_source'].append(SVNPoller(
    repourl = 'svn://gcc.gnu.org/svn/gcc',
    pollAtLaunch = True,
    split_file = util.svn.split_file_branches,
    pollinterval = 60 * 3))

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

# Catch things like PR gcc/42, PR16, PR 16 or bug #11,
# and turn them into gcc bugzilla URLs.
cc_re_tuple = (r'(PR [a-z]+/|PR ?|#)(\d+)',
	           r'https://gcc.gnu.org/bugzilla/show_bug.cgi?id=\2')

c['www'] = {
    'host': 'localhost',
    'port': 8010,
    'plugins': {
        'console_view': True,
        'waterfall_view': True,
        'grid_view': True
    }
}

## The following class is a hack.  It is needed because Builbot's
## webserver treats everything it doesn't know as text/html.  Sigh...
# class WebStatusWithTextDefault(html.WebStatus):
#     def __init__ (self, http_port, authz, **kwargs):
#         html.WebStatus.__init__ (self, http_port = http_port,
#                                  authz = authz, **kwargs)

#     def setupSite(self):
#         result = html.WebStatus.setupSite(self)
#         self.site.resource.defaultType = r"text/plain"
#         return result

# authz_cfg=authz.Authz(
#     # change any of these to True to enable; see the manual for more
#     # options
# #    auth=auth.BasicAuth([("t","t")]),
#     gracefulShutdown = False,
#     forceBuild = True, # use this to test your slave once it is set up
#     forceAllBuilds = True,  # ..or this
#     pingBuilder = False,
#     stopBuild = True,
#     stopAllBuilds = True,
#     cancelPendingBuild = True,
#)
#c['status'].append(WebStatusWithTextDefault (http_port=8010, authz=authz_cfg))
#c['status'].append (html.WebStatus (http_port = 8010, authz = authz_cfg))

#c['status'].append(html.WebStatus(http_port=8010,
#				  forceBuild = True,
#				  allowForce=False,
#				  order_console_by_time=True,
#				  changecommentlink=cc_re_tuple))

#from buildbot.status import words
#c['status'].append(words.IRC(host="irc.yyz.redhat.com", nick="gccbot",
#			     channels=["#gccbuild"]))

import smtplib
import socket
from email.mime.text import MIMEText

def SendRootMessageGCCTesters (branch, change, rev,
                               istrysched = False,
                               try_to = None):
    global GCC_MAIL_TO, GCC_MAIL_FROM

    if istrysched:
        f = "/tmp/gcc-buildbot-%s-try.lock" % rev
    else:
        f = "/tmp/gcc-buildbot-%s.lock" % rev

    if os.path.exists (f):
        # The message has already been sent
        return

    # WE HAVE TO REMEMBER TO CLEAN THESE FILES REGULARLY
    open (f, 'w').close ()

    if not istrysched:
        text = ""
        text += "*** TEST RESULTS FOR COMMIT %s ***\n\n" % rev

        text += "Author: %s\n" % change.who
        text += "Branch: %s\n" % branch
        text += "Commit: %s\n\n" % rev

        text += change.comments.split ('\n')[0] + "\n\n"
        text += '\n'.join (change.comments.split ('\n')[1:])

        chg_title = change.comments.split ('\n')[0]
        text = text.encode ('ascii', 'ignore').decode ('ascii')
    else:
        text = ""
        text += "*** TEST RESULTS FOR TRY BUILD ***\n\n"

        text += "Branch: %s\n" % branch
        text += "Commit tested against: %s\n\n" % rev

        text += "Patch tested:\n\n"
        text += change

        chg_title = "Try Build against commit %s" % rev
        text = text.encode ('ascii', 'ignore').decode ('ascii')

    mail = MIMEText (text)
    if branch == 'trunk':
        sbj = "[gcc] %s" % chg_title
    else:
        sbj = "[gcc/%s] %s" % (branch, chg_title)

    mail['Subject'] = sbj
    mail['From'] = GCC_MAIL_FROM
    if not istrysched:
        mail['To'] = GCC_MAIL_TO
        mailto = GCC_MAIL_TO
        mail['Message-Id'] = "<%s@gcc-build>" % rev
    else:
        mail['To'] = try_to
        mailto = try_to
        mail['Message-Id'] = "<%s-try@gcc-build>" % rev

    s = smtplib.SMTP ('localhost')
    s.sendmail (GCC_MAIL_FROM, [ mailto ], mail.as_string ())
    s.quit ()

def make_breakage_lockfile_prefix ():
    return "/tmp/gcc-buildbot-breakage-report-"

def SendAuthorMessage (name, change, text_prepend):
    """Send a message to the author of the commit if it broke GCC.

We use a lock file to avoid reporting the breakage to different
people.  This may happen, for example, if a commit X breaks GCC, but
subsequent commits are made after X, by different people."""
    global GCC_MAIL_FROM

    lockfile = "%s%s" % (make_breakage_lockfile_prefix (), name)

    if os.path.exists (lockfile):
        # This means we have already reported this failure for this
        # builder to the author.
        return

    # This file will be cleaned the next time we run
    # MessageGCCTesters, iff the build breakage has been fixed.
    open (lockfile, 'w').close ()

    rev = change.revision
    to = change.who.encode ('ascii', 'ignore').decode ('ascii')
    title = change.comments.split ('\n')[0]

    sbj = 'Your commit \'%s\' broke GCC' % title

    text = "Hello there,\n\n"
    text += "Your commit:\n\n"
    text += "\t%s\n" % title
    text += "\t%s\n\n" % rev
    text += "broke GCC.  Please fix it, or the GCC gods will get you.\n\n"
    text += "You can find details of the breakage below.\n\n"
    text += "Cheers,\n\n"
    text += "Your GCC BuildBot.\n\n"
    text += "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n"
    text += "\n" + text_prepend

    mail = MIMEText (text)
    mail['Subject'] = sbj
    mail['From'] = GCC_MAIL_FROM
    mail['To'] = to

    s = smtplib.SMTP ('localhost')
    s.sendmail (GCC_MAIL_FROM, [ to ], mail.as_string ())
    s.quit ()

def MessageGCCTesters (mode, name, build, results, master_status):
    """This function is responsible for composing the message that will be
send to the gcc-testers mailing list."""
    git_url = "http://gcc-build.sergiodj.net/cgit"
    branch = build.getSourceStamps ()[0].branch
    cur_change = build.getSourceStamps ()[0].changes[0]
    properties = build.getProperties ()
    isrebuild = properties.getProperty ('isRebuild')

    # Sending the root message to gcc-testers.
    SendRootMessageGCCTesters (branch, cur_change, cur_change.revision)

    # Subject
    subj = "Failures on %s, branch %s" % (name, branch)

    # Body
    text = ""

    # Buildslave name, useful for knowing the exact configuration.
    text += "Buildslave:\n"
    text += "\t%s\n" % build.getSlavename ()

    # Including the link for the full build
    text += "\nFull Build URL:\n"
    text += "\t<%s>\n" % master_status.getURLForThing (build)

    # Commits that were tested.  Usually we should be dealing with
    # only one commit
    text += "\nCommit(s) tested:\n"
    ss_list = build.getSourceStamps ()
    for ss in ss_list:
        for chg in ss.changes:
            text += "\t%s\n" % chg.revision

    # Who's to blame?
    text += "\nAuthor(s) (in the same order as the commits):\n"
    for ss in ss_list:
        for chg in ss.changes:
            text += "\t%s\n" % chg.who

    # Subject of the changes
    text += "\nSubject:\n"
    text += "\t%s\n" % cur_change.comments.split ('\n')[0]

    # URL to find more info about what went wrong.
    text += "\nTestsuite log (gcc.sum and gcc.log) URL(s):\n"
    for ss in ss_list:
        commit_id = get_builder_commit_id (name, ss.revision, ss.branch)
        if commit_id:
            text += "\t<%s/%s/.git/tree/?h=%s&id=%s>\n" % (git_url, name, quote (ss.branch),
                                                           commit_id)
        else:
            text += "\t<Error fetching commit ID for %s>\n" % ss.revision

    # Including the 'regressions' log.  This is the 'diff' of what
    # went wrong.
    text += "\n"
    if isrebuild and isrebuild == 'yes':
        text += "\n*** WARNING: This was a REBUILD request! ***\n"
        text += "*** The previous build (build #%s) MAY NOT BE the ancestor of the current build! ***\n\n" % properties.getProperty ('buildnumber')

    # report_build_breakage will be True if we see a build breakage,
    # i.e., if the 'configure' or the 'compile' steps fail.  In this
    # case, we use this variable to know if we must report the
    # breakage directly to the author.
    report_build_breakage = False

    # found_regressions will be True if the 'regressions' log is not
    # empty.
    found_regressions = False

    for log in build.getLogs ():
        st = log.getStep ()
        if st.getResults ()[0] == FAILURE:
            n = st.getName ()
            if 'No space left on device' in log.getText ():
                text += "*** Internal error on buildslave (no space left on device). ***\n"
                text += "*** Please report this to the buildslave owner (see <%s/buildslaves/%s>) ***\n\n" % (master_status.getBuildbotURL (), build.getSlavename ())
                continue
            elif n == 'update gcc master repo':
                text += "*** Failed to update master GCC git repository.  The build can continue. ***\n\n"
                continue
            elif n == 'update gcc repo':
                text += "*** Failed to update GCC git repository.  This is probably a timeout problem. ***\n\n"
                break
            elif n == 'configure gcc':
                text += "*** Failed to configure GCC. ***\n"
                text += "============================\n"
                text += log.getText ()
                text += "============================\n"
                subj = "*** COMPILATION FAILED *** " + subj
                report_build_breakage = True
                break
            elif n == 'compile gcc':
                text += "*** Failed to compiled GCC.  ***\n"
                text += "============================\n"
                ct = log.getText ().decode ('ascii', 'ignore')
                if len (ct) > 100000:
                    text += "\n+++ The full log is too big to be posted here."
                    text += "\n+++ These are the last 100 lines of it.\n\n"
                    ctt = ct.split ('\n')[-100:]
                    ct = '\n'.join (ctt)
                    text += ct
                else:
                    text += ct
                text += "============================\n"
                subj = "*** COMPILATION FAILED *** " + subj
                report_build_breakage = True
                break
            elif n == 'regressions' and log.getName () == 'regressions':
                text += "*** Diff to previous build ***\n"
                text += "============================\n"
                text += log.getText ()
                text += "============================\n"
                found_regressions = True
                break

    # Including the 'xfail' log.  It is important to say which tests
    # we are ignoring.
    if found_regressions:
        if os.path.exists (os.path.join (gcc_web_base, name)):
            xfail_commit = os.path.join (gcc_web_base, name, 'xfails', branch, '.last-commit')
            text += "\n\n*** Complete list of XFAILs for this builder ***\n\n"
            if os.path.exists (xfail_commit):
                with open (xfail_commit, 'r') as f:
                    com = f.read ().strip ('\n')
                    text += "To obtain the list of XFAIL tests for this builder, go to:\n\n"
                    text += "\t<http://git.sergiodj.net/?p=gcc-xfails.git;a=blob;f=xfails/%s/xfails/%s/xfail;hb=%s>\n\n" % (name, branch, com)
                    text += "You can also see a pretty-printed version of the list, with more information\n"
                    text += "about each XFAIL, by going to:\n\n"
                    text += "\t<http://git.sergiodj.net/?p=gcc-xfails.git;a=blob;f=xfails/%s/xfails/%s/xfail.table;hb=%s>\n" % (name, branch, com)
            else:
                text += "FAILURE TO OBTAIN THE COMMIT FOR THE XFAIL LIST.  PLEASE CONTACT THE BUILDBOT ADMIN.\n"
    text += "\n"

    if report_build_breakage:
        subj += " *** BREAKAGE ***"
        SendAuthorMessage (name, cur_change, text)
    else:
        # There is no build breakage anymore!  Yay!  Now, let's see if
        # we need to clean up any lock file from previous breaks.
        lockfile = "%s%s" % (make_breakage_lockfile_prefix (), name)
        if os.path.exists (lockfile):
            # We need to clean the lockfile.  Garbage-collect it here.
            os.remove (lockfile)

    return { 'body' : text,
             'type' : 'plain',
             'subject' : subj }

def MessageGCCTestersTryBuild (mode, name, build, results, master_status):
    """This function is responsible for composing the message that will be
send to the gcc-testers mailing list."""
    git_url = "http://gcc-build.sergiodj.net/cgit"
    branch = build.getSourceStamps ()[0].branch
    sourcestamp = build.getSourceStamps ()[0]
    cur_change = sourcestamp.patch[1]
    properties = build.getProperties ()
    isrebuild = properties.getProperty ('isRebuild')

    try_to = build.getReason ().strip ("'try' job by user ")
    # Sending the root message to gcc-testers.
    SendRootMessageGCCTesters (branch, cur_change, properties.getProperty ('revision'),
                               istrysched = True, try_to = try_to)

    # Subject
    subj = "Try Build on %s, branch %s" % (name, branch)

    # Body
    text = ""

    # Buildslave name, useful for knowing the exact configuration.
    text += "Buildslave:\n"
    text += "\t%s\n" % build.getSlavename ()

    # Including the link for the full build
    text += "\nFull Build URL:\n"
    text += "\t<%s>\n" % master_status.getURLForThing (build)

    # Commits that were tested.  Usually we should be dealing with
    # only one commit
    text += "\nLast commit(s) before Try Build:\n"
    text += "\t%s\n" % sourcestamp.revision

    # URL to find more info about what went wrong.
    text += "\nTestsuite log (gcc.sum and gcc.log) URL(s):\n"
    commit_id = get_builder_commit_id (name, sourcestamp.revision,
                                       sourcestamp.branch)
    if commit_id:
        text += "\t<%s/%s/.git/tree/?h=%s&id=%s>\n" % (git_url, name,
                                                       quote (sourcestamp.branch),
                                                       commit_id)
    else:
        text += "\t<Error fetching commit ID for %s>\n" % sourcestamp.revision

    # found_regressions will be True if the 'regressions' log is not
    # empty.
    found_regressions = False

    for log in build.getLogs ():
        st = log.getStep ()
        n = st.getName ()
        if st.getResults ()[0] == SUCCESS or st.getResults ()[0] == WARNINGS:
            if n == 'regressions':
                text += "\nCongratulations!  No regressions were found in this build!\n\n"
                break
        if st.getResults ()[0] == FAILURE:
            if 'No space left on device' in log.getText ():
                text += "*** Internal error on buildslave (no space left on device). ***\n"
                text += "*** Please report this to the buildslave owner (see <%s/buildslaves/%s>) ***\n\n" % (master_status.getBuildbotURL (), build.getSlavename ())
                continue
            elif n == 'update gcc master repo':
                text += "*** Failed to update master GCC git repository.  The build can continue. ***\n\n"
                continue
            elif n == 'update gcc repo':
                text += "*** Failed to update GCC git repository.  This is probably a timeout problem. ***\n\n"
                break
            elif n == 'configure gcc':
                text += "*** Failed to configure GCC. ***\n"
                text += "============================\n"
                text += log.getText ()
                text += "============================\n"
                subj = "*** COMPILATION FAILED *** " + subj
                break
            elif n == 'compile gcc':
                text += "*** Failed to compiled GCC.  ***\n"
                text += "============================\n"
                ct = log.getText ().decode ('ascii', 'ignore')
                if len (ct) > 100000:
                    text += "\n+++ The full log is too big to be posted here."
                    text += "\n+++ These are the last 100 lines of it.\n\n"
                    ctt = ct.split ('\n')[-100:]
                    ct = '\n'.join (ctt)
                    text += ct
                else:
                    text += ct
                text += "============================\n"
                subj = "*** COMPILATION FAILED *** " + subj
                break
            elif n == 'regressions' and log.getName () == 'regressions':
                text += "*** Diff to previous build ***\n"
                text += "============================\n"
                text += log.getText ()
                text += "============================\n"
                found_regressions = True
                break

    # Including the 'xfail' log.  It is important to say which tests
    # we are ignoring.
    if found_regressions:
        if os.path.exists (os.path.join (gcc_web_base, name)):
            xfail_commit = os.path.join (gcc_web_base, name, 'xfails', branch, '.last-commit')
            text += "\n\n*** Complete list of XFAILs for this builder ***\n\n"
            if os.path.exists (xfail_commit):
                with open (xfail_commit, 'r') as f:
                    com = f.read ().strip ('\n')
                    text += "To obtain the list of XFAIL tests for this builder, go to:\n\n"
                    text += "\t<http://git.sergiodj.net/?p=gcc-xfails.git;a=blob;f=xfails/%s/xfails/%s/xfail;hb=%s>\n\n" % (name, branch, com)
                    text += "You can also see a pretty-printed version of the list, with more information\n"
                    text += "about each XFAIL, by going to:\n\n"
                    text += "\t<http://git.sergiodj.net/?p=gcc-xfails.git;a=blob;f=xfails/%s/xfails/%s/xfail.table;hb=%s>\n" % (name, branch, com)
            else:
                text += "FAILURE TO OBTAIN THE COMMIT FOR THE XFAIL LIST.  PLEASE CONTACT THE BUILDBOT ADMIN.\n"
    text += "\n"

    return { 'body' : text,
             'type' : 'plain',
             'subject' : subj }

from buildbot.reporters import mail

class MyMailNotifier (mail.MailNotifier):
    """Extend the regular MailNotifier class in order to filter e-mails by scheduler."""
    def isMailNeeded (self, build, results):
        prop = build.properties.getProperty ('scheduler')
        if prop.startswith ('racy'):
            return False
        elif prop.startswith ('try'):
            if "TRY" not in self.tags:
                # This means we're dealing with mn.  We only send
                # e-mail on mn_try.
                return False
        else:
            if "TRY" in self.tags:
                # We're dealing with mn_try.
                return False
        return mail.MailNotifier.isMailNeeded (self, build, results)

mn = MyMailNotifier(fromaddr = GCC_MAIL_FROM,
                    sendToInterestedUsers = False,
                    extraRecipients = [ GCC_MAIL_TO ],
                    mode = ('failing'),
                    messageFormatter = MessageGCCTesters,
                    tags = [ "MAIL" ],
                    extraHeaders = { 'X-GCC-Buildbot' : '1',
                                     'In-Reply-To' : WithProperties ("<%s@gcc-build>",
                                                                     'got_revision') })

class LookupEmailTryBuild (object):
    implements (IEmailLookup)

    def getAddress (self, name):
        # List of [ dir, sorted_reverse ]
        tryjobdir = [ [ os.path.expanduser ("~/try_ssh_jobdir/new/"), False ],
                      [ os.path.expanduser ("~/try_ssh_jobdir/cur/"), True ] ]
        name_re = re.compile (".*(%s <.*@.*>),.*" % name, flags = re.UNICODE)
        for directory, sort_order in tryjobdir:
            for _, _, filenames in os.walk (directory):
                for f in sorted (filenames, reverse = sort_order):
                    with open (os.path.join (directory, f), 'r') as myf:
                        for line in reversed (myf.readlines ()):
                            m = re.match (name_re, line)
                            if m:
                                return m.group (1)

mn_try = MyMailNotifier(fromaddr = GCC_MAIL_FROM,
                        sendToInterestedUsers = True,
                        mode = ( 'failing', 'passing', 'warnings' ),
                        messageFormatter = MessageGCCTestersTryBuild,
                        lookup = LookupEmailTryBuild (),
                        tags = [ "MAIL", "TRY"  ],
                        extraHeaders = { 'X-GCC-Buildbot' : '1',
                                         'In-Reply-To' : WithProperties ("<%s-try@gcc-build>",
                                                                         'got_revision') })

c['status'].append (mn)
c['status'].append (mn_try)

c['title'] = "GCC"
c['titleURL'] = "https://gcc.gnu.org/"

c['buildbotURL'] = "http://gcc-buildbot.linki.tools/"

c['db'] = {
    'db_url' : "sqlite:///state.sqlite",
}

#####################
#### Build steps ####
#####################

## This is where we define our build steps.  A build step is some
## command/action that buildbot will perform while building GCC.  See
## the documentation on each build step class to understand what it
## does.

class CloneOrUpdateGCCRepo (SVN):
    """This build step updates the repository.  For each buildslave, we have one GCC svn repository. """
    name = "update gcc trunk repo"
    description = r"fetching GCC trunk sources"
    descriptionDone = r"fetched GCC trunk sources"
    def __init__ (self):
        SVN.__init__ (self,
                      baseURL = 'svn://gcc.gnu.org/svn/gcc/',
                      defaultBranch = 'trunk',
                      workdir = WithProperties (r"%s/../gcc/", r'builddir'),
                      mode = r'update',
                      # Unfortunately we need this due to GCC SVN unreliability
                      # 10 retries with 60sec delay
                      retry = (60, 10))
        self.haltOnFailure = True

class ConfigureGCC (Configure):
    """This build step runs the GCC "configure" command, providing extra
flags for it if needed."""
    name = "configure gcc"
    description = r"configure GCC"
    descriptionDone = r"configured GCC"
    def __init__ (self, extra_conf_flags, **kwargs):
        Configure.__init__ (self, **kwargs)
        self.workdir = WithProperties (r"%s", r'builddir')
        self.command = ['../../gcc/configure'] + extra_conf_flags

class CompileGCC (Compile):
    """This build step runs "make" to compile the GCC sources.  It
provides extra "make" flags to "make" if needed.  It also uses the
"jobs" properties to figure out how many parallel jobs we can use when
compiling GCC; this is the "-j" flag for "make".  The value of the
"jobs" property is set at the "config.json" file, for each
buildslave."""
    name = "compile gcc"
    description = r"compile GCC"
    descriptionDone = r"compiled GCC"
    def __init__ (self, make_command = 'make', extra_make_flags = [],
                  **kwargs):
        Compile.__init__ (self, **kwargs)
        self.workdir = WithProperties (r"%s", r'builddir')
        self.command = ['%s' % make_command,
                        WithProperties (r"-j%s", r'jobs'),
                        'all'] + extra_make_flags

class TestGCC (ShellCommand):
    """This build step runs the full testsuite for GCC.  It can run in
parallel mode (see BuildAndTestGCCFactory below), and it will also
provide any extra flags for "make" if needed."""
    name = "test gcc"
    description = r"testing GCC"
    descriptionDone = r"tested GCC"
    def __init__ (self, make_command = 'make', extra_make_check_flags = [],
                  test_env = {}, **kwargs):
        ShellCommand.__init__ (self,
                               decodeRC = { 0 : SUCCESS,
                                            1 : SUCCESS,
                                            2 : SUCCESS },
                               **kwargs)

        self.workdir = WithProperties (r"%s/build/", r'builddir')
        self.command = ['%s' % make_command,
                        '-k',
                        'check'] + extra_make_check_flags

        self.env = test_env
        # Needed because of dejagnu
        self.haltOnFailure = False
        self.flunkOnFailure = False
        self.flunkOnWarnings = False

def scheduler_is_try (step):
    return step.getProperty ('scheduler').startswith ('try')
def scheduler_is_not_try (step):
    return not scheduler_is_try (step)

#######################
#### Build Factory ####
#######################

## This is where our Build Factory is defined.  A build factory is a
## description of the build process, which is made in terms of build
## steps.  The BuildAndTestGCCFactory is the main build factory for
## GCC; it is configurable and should be more than enough to describe
## most builds.

class BuildAndTestGCCFactory (factory.BuildFactory):
    """This is the main build factory for the GCC project.  It was made to
be very configurable, and should be enough to describe most builds.
The parameters of the class are:

    - ConfigureClass: set this to be the class (i.e., build step) that
      will be called to configure GCC.  It needs to accept the same
      arguments as the ConfigureGCC class above.  The default is to
      use ConfigureGCC.

    - CompileClass: set this to be the class (i.e., build step) that
      will be called to compile GCC.  It needs to accept the same
      arguments as the CompileGCC class above.  The default is to use
      CompileGCC.

    - TestClass: set this to be the class (i.e., build step) that will
      be called to test GCC.  It needs to accept the same arguments as
      the TestGCC class above.  The default is to use TestGCC.

    - extra_conf_flags: extra flags to be passed to "configure".
      Should be a list (i.e., []).  The default is None.

    - enable_targets_all: set this to True to pass
      '--enable-targets=all' to configure.  The default is True.

    - extra_make_flags: extra flags to be passed to "make", when
      compiling.  Should be a list (i.e., []).  The default is None.

    - extra_make_check_flags: extra flags to be passed to "make
      check", when testing.  Should be a list (i.e., []).  The default
      is None.

    - test_env: extra environment variables to be passed to "make
      check", when testing.  Should be a dictionary (i.e., {}).  The
      default is None.

    - test_parallel: set to True if the test shall be parallelized.
      Default is False.  Beware that parallelizing tests may cause
      some failures due to limited system resources.

    - make_command: set the command that will be called when running
      'make'.  This is needed because BSD systems need to run 'gmake'
      instead of make.  Default is 'make'.

    """
    ConfigureClass = ConfigureGCC
    CompileClass = CompileGCC
    TestClass = TestGCC

    # Set this to False to skip the test
    run_testsuite = True

    extra_conf_flags = None
    enable_targets_all = True

    extra_make_flags = None
    extra_make_check_flags = None
    test_env = None

    # Set this to false to disable parallel testing (i.e., do not use
    # FORCE_PARALLEL)
    test_parallel = True

    # Set this to the make command that you want to run in the "make"
    # steps.
    make_command = 'make'

    def __init__ (self, architecture_triplet = []):
        factory.BuildFactory.__init__ (self)

        self.architecture_triplet = architecture_triplet

        self.addStep (RemoveDirectory (dir = WithProperties (r"%s/build",
                                                             r'builddir'),
                                       description = r"removing old build dir",
                                       descriptionDone = r"removed old build dir"))
        self.addStep (CloneOrUpdateGCCRepo ())

        # if self.run_testsuite:
        #     self.addStep (CopyOldGCCSumFile (doStepIf = scheduler_is_not_racy_try_do,
        #                                      hideStepIf = scheduler_is_racy_try_hide))

        if not self.extra_conf_flags:
            self.extra_conf_flags = []

        self.addStep (self.ConfigureClass (self.extra_conf_flags + architecture_triplet))

        if not self.extra_make_flags:
            self.extra_make_flags = []
        self.addStep (self.CompileClass (self.make_command, self.extra_make_flags))

        # This last will be executed when the build succeeds.  It is
        # needed in order to cleanup the breakage lockfile, if it
        # exists.
        #self.addStep (CleanupBreakageLockfile (hideStepIf = True))

        if not self.extra_make_check_flags:
            self.extra_make_check_flags = []

        if self.run_testsuite:
            if not self.test_env:
                self.test_env = {}

            if self.test_parallel:
                self.extra_make_check_flags.append (WithProperties (r"-j%s", r'jobs'))

            self.addStep (self.TestClass (self.make_command,
                                          self.extra_make_check_flags,
                                          self.test_env,
                                          # Needed because
                                          # gcc/libstdc++-v3/testsuite/libstdc++-dg/conformance.exp
                                          # sometimes takes more than 1200secs (default timeout)
                                          # without producing any output
                                          timeout = 1800))

            # self.addStep (GccCatSumfileCommand (workdir = WithProperties (r'%s/build/gcc/testsuite',
            #                                                               r'builddir'),
            #                                     description = r'analyze test results'))
#            self.addStep (FileUpload (slavesrc = WithProperties (r"%s/build/gcc/testsuite/gcc.log",
#                                                                 r'builddir'),
#                                      masterdest = WithProperties (r"public_html/results/%s/gcc.log",
#                                                                   r'buildername')))
            #self.addStep (SaveGCCResults ())


##################
#### Builders ####
##################

## This section describes our builders.  The builders are instances of
## a build factory, and they will be used to do a specific build of
## the project.
##
## The nomenclature here is important.  Every builder should start
## with the prefix "RunTestGCC", and then be followed by the testing
## scenario that the build will test, followed by "_cXXtYY", where XX
## is the bitness of the compilation, and YY is the bitness of the
## testing.  So, for example, if we are specifically testing GCC
## running the native-gccserver tests, compiling GCC on a 64-bit
## machine, but running the tests in 32-bit mode, our builder would be called:
##
##     RunTestGCCNativeGCCServer_c64t32

class RunTestGCCPlain_c64t64 (BuildAndTestGCCFactory):
    """Compiling for 64-bit, testing on 64-bit."""
    def __init__ (self, **kwargs):
        self.extra_conf_flags = [ '--disable-multilib' ]
        BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCPlain_c32t32 (BuildAndTestGCCFactory):
#     """Compiling on 32-bit, testing on 32-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_conf_flags = [ r'CFLAGS=-m32', 'CXXFLAGS=-m32' ]
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board unix/-m32' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCm32_c64t32 (BuildAndTestGCCFactory):
#     """Compiling on 64-bit, testing on 32-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board unix/-m32' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCNativeGCCServer_c64t64 (BuildAndTestGCCFactory):
#     """Compiling on 64-bit, testing native-gccserver on 64-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board native-gccserver' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCNativeGCCServer_c64t32 (BuildAndTestGCCFactory):
#     """Compiling on 64-bit, testing native-gccserver on 32-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board native-gccserver/-m32' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCNativeGCCServer_c32t32 (BuildAndTestGCCFactory):
#     """Compiling on 32-bit, testing native-gccserver on 32-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_conf_flags = [ 'CFLAGS=-m32', 'CXXFLAGS=-m32' ]
#         self.extra_make_check_flags = [ 'RUNTESTFLAGS=--target_board native-gccserver/-m32']
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCNativeExtendedGCCServer_c64t64 (BuildAndTestGCCFactory):
#     """Compiling on 64-bit, testing native-extended-gccserver on 64-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board native-extended-gccserver' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCNativeExtendedGCCServer_c64t32 (BuildAndTestGCCFactory):
#     """Compiling on 64-bit, testing native-extended-gccserver on 32-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board native-extended-gccserver/-m32' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCNativeExtendedGCCServer_c32t32 (BuildAndTestGCCFactory):
#     """Compiling on 64-bit, testing native-extended-gccserver on 32-bit."""
#     def __init__ (self, **kwargs):
#         self.extra_conf_flags = [ 'CFLAGS=-m32', 'CXXFLAGS=-m32' ]
#         self.extra_make_check_flags = [ r'RUNTESTFLAGS=--target_board native-extended-gccserver/-m32' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCIndexBuild (BuildAndTestGCCFactory):
#     """Testing with the "cc-with-tweaks.sh" passing -i."""
#     def __init__ (self, **kwargs):
#         self.extra_make_check_flags = [ WithProperties (r'CC_FOR_TARGET=/bin/sh %s/binutils-gcc/gcc/contrib/cc-with-tweaks.sh -i gcc', r'builddir'),
#                                         WithProperties (r'CXX_FOR_TARGET=/bin/sh %s/binutils-gcc/gcc/contrib/cc-with-tweaks.sh -i g++', r'builddir') ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCIndexBuild_c32t32 (BuildAndTestGCCFactory):
#     """Testing with the "cc-with-tweaks.sh" passing -i.  32-bit version"""
#     def __init__ (self, **kwargs):
#         self.extra_conf_flags = [ 'CFLAGS=-m32', 'CXXFLAGS=-m32' ]
#         self.extra_make_check_flags = [ WithProperties (r'CC_FOR_TARGET=/bin/sh %s/binutils-gcc/gcc/contrib/cc-with-tweaks.sh -i gcc', r'builddir'),
#                                         WithProperties (r'CXX_FOR_TARGET=/bin/sh %s/binutils-gcc/gcc/contrib/cc-with-tweaks.sh -i g++', r'builddir'),
#                                         'RUNTESTFLAGS=--target_board unix/-m32' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# # Class for only building GCC, without testing

# class RunTestGCCPlainBuildWithCxx_c64notest (BuildAndTestGCCFactory):
#     """Compiling for 64-bit with --enable-build-with-cxx.  We do not test
# anything for now."""
#     def __init__ (self, **kwargs):
#         self.extra_conf_flags = [ '--enable-build-with-cxx' ]
#         self.run_testsuite = False
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCPlainBuildWithC_c64notest (BuildAndTestGCCFactory):
#     """Compiling for 64-bit with --enable-build-with-cxx=no.  We do not test
# anything for now."""
#     def __init__ (self, **kwargs):
#         self.extra_conf_flags = [ '--enable-build-with-cxx=no' ]
#         self.run_testsuite = False
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# # Classes needed for BSD systems

# class RunTestGCCBSD_Common (BuildAndTestGCCFactory):
#     """Common BSD test configurations"""
#     def __init__ (self, **kwargs):
#         self.make_command = 'gmake'
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCPlainBSD_c64t64 (RunTestGCCPlain_c64t64, RunTestGCCBSD_Common):
#     """Compiling for 64-bit, testing on 64-bit."""
#     pass

# class RunTestGCCIndexBuildBSD (RunTestGCCIndexBuild, RunTestGCCBSD_Common):
#     """Testing with the "cc-with-tweaks.sh" passing -i.  FIXME: include bitness here."""
#     pass

# # Classes needed for AIX systems

# class RunTestGCCAIX_Common (BuildAndTestGCCFactory):
#     """Common AIX test configurations"""
#     def __init__ (self, **kwargs):
#         # Unfortunately we have to disable -Werror there...
#         # ... and now we also have to disable Python.
#         self.extra_conf_flags = [ '--disable-werror', '--with-python=no' ]
#         self.enable_targets_all = False
#         self.make_command = 'gmake'
#         self.extra_make_flags = [ 'MAKEINFO=true' ]
#         BuildAndTestGCCFactory.__init__ (self, **kwargs)

# class RunTestGCCPlainAIX (RunTestGCCAIX_Common, RunTestGCCPlain_c64t64):
#     """Compiling for AIX"""
#     pass

# All branches that are going to be watched.
all_gcc_filter = ChangeFilter (branch_fn = should_watch_branch)

# This function prevents a builder to build more than one build at the
# same time.  This is needed because we do not have a way to lock the
# svn repository containing the test results of the builder, so
# simultaneous builds can cause a mess when committing the test
# results.
# def DefaultGCCCanStartBuild (builder, buildslave, buildrequest):
#     return not builder.building

# Currently ignoring changes in gcc/doc/
files_ignored_re = re.compile ("(gcc/doc/).*")

def DefaultGCCfileIsImportant (change):
    """Implementation of fileIsImportant method, in order to decide which
changes to build on GCC."""
    only_changelog = True

    # Do not build the 'GCC Administrator' commits, that are used to
    # increment the date on some files.
    if 'GCC Administrator' in change.who:
        return False

    # Filter out commits that only modify the ChangeLog files.
    for filename in change.files:
        if 'ChangeLog' not in filename:
            only_changelog = False
            break

    if only_changelog:
        return False

    for filename in change.files:
        if not re.match (files_ignored_re, filename):
            return True

    return False

def prioritizeTryBuilds (builder, requests):
    for r in requests:
        if r.properties.getProperty ('scheduler').startswith ('try'):
            return r
    return requests[0]

###############################
#### Configuration loading ####
###############################

## This is "the heart" of this file.  This function is responsible for
## loading the configuration present in the "lib/config.json" file,
## and initializing everything needed for BuildBot to work.  Most of
## this function was copied from WebKit's BuildBot configuration, with
## lots of tweaks.

def load_config (c):
    config = load (open ("lib/config.json"))
    passwd = load (open ("lib/passwords.json"))

    c['slaves'] = [BuildSlave (slave['name'], passwd[slave['name']],
                               max_builds = 1,
                               notify_on_missing = [ str (slave['admin']) ],
                               missing_timeout = 300,
                               properties = { 'jobs' : slave['jobs'] })
                   for slave in config['slaves']]

    c['schedulers'] = []
    for s in config['schedulers']:
        # Ugh :-/.  There should be no special case here...
        if s['type'] != 'Nightly' and s['type'] != 'Try_Jobdir':
            s['treeStableTimer'] = None
            s['fileIsImportant'] = DefaultGCCfileIsImportant
        elif s['type'] == 'Nightly':
            try:
                s['dayOfWeek'] = int (s['dayOfWeek'])
            except:
                pass
            try:
                s['hour'] = int (s['hour'])
            except:
                pass
            try:
                s['minute'] = int (s['minute'])
            except:
                pass
            s['onlyIfChanged'] = False
            s['branch'] = 'trunk'
        elif s['type'] == 'Try_Jobdir':
            s['properties']  = { 'isTrySched' : 'yes' }
        if "change_filter" in s:
            s['change_filter'] = globals ()[s['change_filter']]
        kls = globals ()[s.pop ('type')]
        d = dict (map (lambda key_value_pair : (str (key_value_pair[0]),
                                                key_value_pair[1]),
                       s.items ()))
        c['schedulers'].append (kls (**d))

    c['builders'] = []
    for b in config['builders']:
        myenv = {}

        if 'arch_triplet' in b:
            architecture_triplet = [ b.pop ('arch_triplet') ]
        else:
            architecture_triplet = []

        btype = b.pop ('type')
        factory = globals ()[ "RunTestGCC%s" % btype ]
        b['factory'] = factory (architecture_triplet = architecture_triplet)
        #b['canStartBuild'] = DefaultGCCCanStartBuild
        #b['mergeRequests'] = False

        ntags = [str (x) for x in b['tags']]
        b['tags'] = ntags

        # AIX hack.  Sigh...
        try:
            mypath = b.pop ('PATH')
            myenv['PATH'] = mypath
            b['env'] = myenv
        except KeyError:
            pass

        b['nextBuild'] = prioritizeTryBuilds

        c['builders'].append (b)

load_config (c)


#### Force Scheduler configuration
c['schedulers'].append(schedulers.ForceScheduler(
    name="force",
    builderNames=[ 'Fedora-x86_64-m64' ],

    branch=util.ChoiceStringParameter(name='branch',
                                      choices=['trunk'],
                                      default='trunk'),
    reason=util.StringParameter(name='reason',
                                label='reason:<br/>',
                                required=True,
                                size=80),
    revision=util.FixedParameter(name='revision', default=''),
    repository=util.FixedParameter(name='repository', default=''),
    project=util.FixedParameter(name='project', default=''),

    username=util.UserNameParameter(label='your name:<br/>',
                                    required=True,
                                    size=80)
    ))

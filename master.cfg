# -*- python -*-
# ex: set syntax=python:

from buildbot.plugins import *
from buildbot.schedulers.basic import AnyBranchScheduler
from buildbot.schedulers.timed import Nightly
from buildbot.schedulers.trysched import Try_Jobdir
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.process import factory
from buildbot.process.properties import Property
from buildbot.steps.shell import Compile
from buildbot.steps.shell import Configure
from buildbot.steps.shell import ShellCommand
from buildbot.steps.shell import SetPropertyFromCommand
from buildbot.steps.transfer import FileUpload
from buildbot.steps.source.svn import SVN
from buildbot.steps.worker import RemoveDirectory, MakeDirectory
from buildbot.changes.filter import ChangeFilter
from buildbot.changes.svnpoller import SVNPoller
from buildbot.process.results import SUCCESS, WARNINGS, FAILURE, EXCEPTION
from lib.jv import extract_properties_jv
from urllib.parse import quote
from functools import partial
import os
import urllib
from json import load
import re

####################################
####################################
#### GCC BuildBot Configuration ####
####################################
####################################

###############################
#### General Configuration ####
###############################

# This is the dictionary that the buildmaster pays attention to. We
# also use a shorter alias to save typing.
c = BuildmasterConfig = {}

# # Base directory for the web server.  This is needed in order to
# # compare the test results.
# gcc_web_base = os.path.expanduser (os.path.join (basedir,
#                                                  'public_html',
#                                                  'results'))
# set_web_base (gcc_web_base)

GCC_MAIL_FROM = 'pmatos+gcc-buildbot@linki.tools'
GCC_MAIL_TO = 'gcc-buildbot+botmail@linki.tools'

# 'protocols' contains information about protocols which master will use for
# communicating with workers.
c['protocols'] = {'pb': {'port': 9989}}

# Revision links to gcc svn browser
c['revlink'] = util.RevlinkMatch([r'svn://gcc.gnu.org/svn/gcc.*'],
                                 r'https://gcc.gnu.org/viewcvs/gcc?view=revision&revision=%s')

# Since we don't have enough workers, lets merge all requests
#c['mergeRequests'] = True

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

# RE representing which branches to track on the GCC repository
# Track trunk and release branches
branches_to_watch = re.compile ("(trunk|gcc-\d+\.\d+-branch)")

# Function which decides whether BRANCH should be used or not
def should_watch_branch (branch):
    if branch is None:
        branch = 'trunk'
    elif branch.startswith('branches'):
        branch = branch.split('/', maxsplit=1)[1]
    if re.match (branches_to_watch, branch):
        return True
    else:
        return False

BASE_REPO = 'svn://gcc.gnu.org/svn/gcc'

c['change_source'] = []
c['change_source'].append(SVNPoller(
    repourl = BASE_REPO,
    pollAtLaunch = True,
    split_file = util.svn.split_file_branches,
    pollinterval = 10))

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

# Catch things like PR gcc/42, PR16, PR 16 or bug #11,
# and turn them into gcc bugzilla URLs.
cc_re_tuple = (r'(PR [a-z]+/|PR ?|#)(\d+)',
	           r'https://gcc.gnu.org/bugzilla/show_bug.cgi?id=\2')

c['www'] = {
    'port': 8010,
    'plugins': {
        'console_view': True,
        'waterfall_view': True,
        'grid_view': True
    }
}

## The following class is a hack.  It is needed because Builbot's
## webserver treats everything it doesn't know as text/html.  Sigh...
# class WebStatusWithTextDefault(html.WebStatus):
#     def __init__ (self, http_port, authz, **kwargs):
#         html.WebStatus.__init__ (self, http_port = http_port,
#                                  authz = authz, **kwargs)

#     def setupSite(self):
#         result = html.WebStatus.setupSite(self)
#         self.site.resource.defaultType = r"text/plain"
#         return result

# authz_cfg=authz.Authz(
#     # change any of these to True to enable; see the manual for more
#     # options
# #    auth=auth.BasicAuth([("t","t")]),
#     gracefulShutdown = False,
#     forceBuild = True, # use this to test your worker once it is set up
#     forceAllBuilds = True,  # ..or this
#     pingBuilder = False,
#     stopBuild = True,
#     stopAllBuilds = True,
#     cancelPendingBuild = True,
#)
#c['status'].append(WebStatusWithTextDefault (http_port=8010, authz=authz_cfg))
#c['status'].append (html.WebStatus (http_port = 8010, authz = authz_cfg))

#c['status'].append(html.WebStatus(http_port=8010,
#				  forceBuild = True,
#				  allowForce=False,
#				  order_console_by_time=True,
#				  changecommentlink=cc_re_tuple))

#from buildbot.status import words
#c['status'].append(words.IRC(host="irc.yyz.redhat.com", nick="gccbot",
#			     channels=["#gccbuild"]))

from lib.notifications import MyMailNotifier, MessageGCCTesters, MessageGCCTestersTryBuild, LookupEmailTryBuild

mn = MyMailNotifier(fromaddr = GCC_MAIL_FROM,
                    sendToInterestedUsers = False,
                    extraRecipients = [ GCC_MAIL_TO ],
                    mode = ('failing'),
                    messageFormatter = MessageGCCTesters,
                    tags = [ "MAIL" ],
                    extraHeaders = {
                        'X-GCC-Buildbot' : '1',
                        'In-Reply-To' : util.Interpolate("<%(prop:got_revision)s@gcc-build>")
                    })

mn_try = MyMailNotifier(fromaddr = GCC_MAIL_FROM,
                        sendToInterestedUsers = True,
                        mode = ( 'failing', 'passing', 'warnings' ),
                        messageFormatter = MessageGCCTestersTryBuild,
                        lookup = LookupEmailTryBuild (),
                        tags = [ "MAIL", "TRY"  ],
                        extraHeaders = {
                            'X-GCC-Buildbot' : '1',
                            'In-Reply-To' : util.Interpolate("<%(prop:got_revision)s-try@gcc-build>")
                        })

c['services'] = []
#c['services'].append (mn)
#c['services'].append (mn_try)

c['title'] = "GCC"
c['titleURL'] = "https://gcc.gnu.org/"

c['buildbotURL'] = "https://gcc-buildbot.linki.tools/"

#####################
#### Build steps ####
#####################

## This is where we define our build steps.  A build step is some
## command/action that buildbot will perform while building GCC.  See
## the documentation on each build step class to understand what it
## does.

class CloneOrUpdateGCCRepo (SVN):
    """This build step updates the repository.  For each buildslave, we have one GCC svn repository. """
    name = "update gcc trunk repo"
    description = r"fetching GCC trunk sources"
    descriptionDone = r"fetched GCC trunk sources"
    def __init__ (self, workdir, repourl):
        SVN.__init__ (self,
                      repourl = repourl,
                      workdir = workdir,
                      mode = 'incremental',
                      # Unfortunately we need this due to GCC SVN unreliability
                      # 10 retries with 60sec delay
                      retry = (60, 10))
        self.haltOnFailure = True

class ConfigureGCC (Configure):
    """This build step runs the GCC "configure" command, providing extra
flags for it if needed."""
    name = "configure gcc"
    description = r"configure GCC"
    descriptionDone = r"configured GCC"
    def __init__ (self, extra_conf_flags, workdir, cfgpath, **kwargs):
        Configure.__init__ (self, **kwargs)
        self.workdir = workdir
        self.command = [cfgpath] + extra_conf_flags

class CompileGCC (Compile):
    """This build step runs "make" to compile the GCC sources.  It
provides extra "make" flags to "make" if needed.  It also uses the
"jobs" properties to figure out how many parallel jobs we can use when
compiling GCC; this is the "-j" flag for "make".  The value of the
"jobs" property is set at the "config.json" file, for each
buildslave."""
    name = "compile gcc"
    description = r"compile GCC"
    descriptionDone = r"compiled GCC"
    def __init__ (self, workdir, make_command = 'make', extra_make_flags = [],
                  **kwargs):
        Compile.__init__ (self, **kwargs)
        self.workdir = workdir
        self.command = ['%s' % make_command,
                        util.Interpolate("-j%(prop:jobs)s"),
                        'all'] + extra_make_flags

class TestGCC (ShellCommand):
    """This build step runs the full testsuite for GCC.  It can run in
parallel mode (see BuildAndTestGCCFactory below), and it will also
provide any extra flags for "make" if needed."""
    name = "test gcc"
    description = r"testing GCC"
    descriptionDone = r"tested GCC"
    def __init__ (self, workdir, make_command = 'make', extra_make_check_flags = [],
                  test_env = {}, **kwargs):
        ShellCommand.__init__ (self,
                               decodeRC = { 0 : SUCCESS,
                                            1 : SUCCESS,
                                            2 : SUCCESS },
                               **kwargs)

        self.workdir = workdir
        self.command = ['%s' % make_command,
                        util.Interpolate("-j%(prop:jobs)s"),
                        '-k',
                        'check'] + extra_make_check_flags

        self.env = test_env
        # Needed because of dejagnu
        self.haltOnFailure = False
        self.flunkOnFailure = False
        self.flunkOnWarnings = False

def scheduler_is_try (step):
    return step.getProperty ('scheduler').startswith ('try')
def scheduler_is_not_try (step):
    return not scheduler_is_try (step)

#######################
#### Build Factory ####
#######################

## This is where our Build Factory is defined.  A build factory is a
## description of the build process, which is made in terms of build
## steps.  The BuildAndTestGCCFactory is the main build factory for
## GCC; it is configurable and should be more than enough to describe
## most builds.

class BuildAndTestGCCFactory (factory.BuildFactory):
    """This is the main build factory for the GCC project.  It was made to
be very configurable, and should be enough to describe most builds.
The parameters of the class are:

    - ConfigureClass: set this to be the class (i.e., build step) that
      will be called to configure GCC.  It needs to accept the same
      arguments as the ConfigureGCC class above.  The default is to
      use ConfigureGCC.

    - CompileClass: set this to be the class (i.e., build step) that
      will be called to compile GCC.  It needs to accept the same
      arguments as the CompileGCC class above.  The default is to use
      CompileGCC.

    - TestClass: set this to be the class (i.e., build step) that will
      be called to test GCC.  It needs to accept the same arguments as
      the TestGCC class above.  The default is to use TestGCC.

    - extra_conf_flags: extra flags to be passed to "configure".
      Should be a list (i.e., []).  The default is None.

    - enable_targets_all: set this to True to pass
      '--enable-targets=all' to configure.  The default is True.

    - extra_make_flags: extra flags to be passed to "make", when
      compiling.  Should be a list (i.e., []).  The default is None.

    - extra_make_check_flags: extra flags to be passed to "make
      check", when testing.  Should be a list (i.e., []).  The default
      is None.

    - test_env: extra environment variables to be passed to "make
      check", when testing.  Should be a dictionary (i.e., {}).  The
      default is None.

    - test_parallel: set to True if the test shall be parallelized.
      Default is False.  Beware that parallelizing tests may cause
      some failures due to limited system resources.

    - make_command: set the command that will be called when running
      'make'.  This is needed because BSD systems need to run 'gmake'
      instead of make.  Default is 'make'.

    """
    ConfigureClass = ConfigureGCC
    CompileClass = CompileGCC
    TestClass = TestGCC

    # Set this to False to skip the test
    run_testsuite = True

    extra_conf_flags = None
    enable_targets_all = True

    extra_make_flags = None
    extra_make_check_flags = None
    test_env = None

    # Set this to false to disable parallel testing (i.e., do not use
    # FORCE_PARALLEL)
    test_parallel = True

    # Set this to the make command that you want to run in the "make"
    # steps.
    make_command = 'make'

    def __init__ (self, architecture_triplet = []):

        factory.BuildFactory.__init__ (self)

        self.architecture_triplet = architecture_triplet

        # Builddir where the build itself will take place.
        builddir = util.Interpolate("%(prop:builddir)s/build")

        # Directory to clone gcc to
        srcdir = util.Interpolate("%(prop:builddir)s/%(src::branch:~trunk)s")

        # Path to configure
        # TODO: I wonder how to append two renderables to reuse srcdir definition
        configurepath = util.Interpolate("%(kw:srcdir)s/configure", srcdir=srcdir)

        # Path to data directory where we store stuff in master


        self.addStep(MakeDirectory(dir = builddir))

        self.addStep (CloneOrUpdateGCCRepo(workdir = srcdir,
                                           repourl = util.Interpolate("{}/%(src::branch:~trunk)s".format(BASE_REPO))))

        if not self.extra_conf_flags:
            self.extra_conf_flags = []

        self.addStep(self.ConfigureClass(self.extra_conf_flags + architecture_triplet,
                                         workdir = builddir,
                                         cfgpath = configurepath))

        if not self.extra_make_flags:
            self.extra_make_flags = []
        self.addStep(self.CompileClass(builddir,
                                       self.make_command,
                                       self.extra_make_flags))

        if not self.extra_make_check_flags:
            self.extra_make_check_flags = []

        if self.run_testsuite:
            if not self.test_env:
                self.test_env = {}

            if self.test_parallel:
                self.extra_make_check_flags.append (util.Interpolate("-j%(prop:jobs)s"))

            self.addStep(self.TestClass(builddir,
                                        self.make_command,
                                        self.extra_make_check_flags,
                                        self.test_env,
                                        # Needed because
                                        # gcc/libstdc++-v3/testsuite/libstdc++-dg/conformance.exp
                                        # sometimes takes more than 1200secs (default timeout)
                                        # without producing any output
                                        timeout = 1800))

            self.addStep(steps.MakeDirectory(dir=util.Interpolate("%(prop:builddir)s/bin")))
            self.addStep(steps.FileDownload(mastersrc='/home/gcc-buildbot/gcc-buildbot/jamais-vu/jv',
                                            workerdest=util.Interpolate("%(prop:builddir)s/bin/jv"),
                                            mode=755))
            self.addStep(steps.SetPropertyFromCommand(command=['bin/jv',
                                                               'summarize',
                                                               util.Interpolate('%(kw:builddir)s/gcc/testsuite/', builddir=builddir)],
                                                      extract_fn=extract_properties_jv))
            self.addStep(steps.SetPropertyFromCommand(command=util.Interpolate('%(kw:builddir)s/gcc/xgcc --version',
                                                                               builddir=builddir),
                                                      property='version'))
            self.addStep(steps.ShellCommand(command=util.Interpolate("find . -name '*.sum' -or -name '*.log' | xargs tar -cvjf test-logs_r%(prop:got_revision)s.tar.bz2"),
                                            workdir=util.Interpolate('%(kw:builddir)s/gcc/testsuite', builddir=builddir)))
            self.addStep(steps.FileUpload(workersrc=util.Interpolate('%(kw:builddir)s/gcc/testsuite/test-logs_r%(prop:got_revision)s.tar.bz2', builddir=builddir),
                                          masterdest=util.Interpolate('/home/gcc-buildbot/data/test-logs_r%(prop:got_revision)s.tar.bz2'),
                                          url=util.Interpolate('data/test-logs_r%(prop:got_revision)s.tar.bz2'),
                                          mode=644))



##################
#### Builders ####
##################

## This section describes our builders.  The builders are instances of
## a build factory, and they will be used to do a specific build of
## the project.
##
## The nomenclature here is important.  Every builder should start
## with the prefix "RunTestGCC", and then be followed by the testing
## scenario that the build will test, followed by "_cXXtYY", where XX
## is the bitness of the compilation, and YY is the bitness of the
## testing.  So, for example, if we are specifically testing GCC
## running the native-gccserver tests, compiling GCC on a 64-bit
## machine, but running the tests in 32-bit mode, our builder would be called:
##
##     RunTestGCCNativeGCCServer_c64t32

class RunTestGCCPlain_c64t64 (BuildAndTestGCCFactory):
    """Compiling for 64-bit, testing on 64-bit."""
    def __init__ (self, **kwargs):
        self.make_command = 'make'
        self.extra_conf_flags = [ '--disable-multilib' ]
        BuildAndTestGCCFactory.__init__ (self, **kwargs)

# All branches that are going to be watched.
all_gcc_filter = ChangeFilter (branch_fn = should_watch_branch)

# This function prevents a builder to build more than one build at the
# same time.  This is needed because we do not have a way to lock the
# svn repository containing the test results of the builder, so
# simultaneous builds can cause a mess when committing the test
# results.
# def DefaultGCCCanStartBuild (builder, buildslave, buildrequest):
#     return not builder.building

# Currently ignoring changes in gcc/doc/
files_ignored_re = re.compile ("(gcc/doc/).*")

def DefaultGCCfileIsImportant (change):
    """Implementation of fileIsImportant method, in order to decide which
changes to build on GCC."""
    only_changelog = True

    # Do not build the 'GCC Administrator' commits, that are used to
    # increment the date on some files.
    if 'GCC Administrator' in change.who:
        return False

    # Filter out commits that only modify the ChangeLog files.
    for filename in change.files:
        if 'ChangeLog' not in filename:
            only_changelog = False
            break

    if only_changelog:
        return False

    for filename in change.files:
        if not re.match (files_ignored_re, filename):
            return True

    return False

def prioritizeTryBuilds (builder, requests):
    for r in requests:
        if r.properties.getProperty ('scheduler').startswith ('try'):
            return r
    return requests[0]

###############################
#### Configuration loading ####
###############################

## This is "the heart" of this file.  This function is responsible for
## loading the configuration present in the "lib/config.json" file,
## and initializing everything needed for BuildBot to work.  Most of
## this function was copied from WebKit's BuildBot configuration, with
## lots of tweaks.

def load_config (c):
    config = load (open ("lib/config.json"))
    passwd = load (open ("lib/passwords.json"))

    c['workers'] = [worker.Worker(w['name'], passwd[w['name']],
                                  max_builds = 1,
                                  notify_on_missing = [ str (w['admin']) ],
                                  missing_timeout = 300,
                                  properties = { 'jobs' : w['jobs'] })
                   for w in config['workers']]

    c['schedulers'] = []
    for s in config['schedulers']:
        # Ugh :-/.  There should be no special case here...
        if s['type'] != 'Nightly' and s['type'] != 'Try_Jobdir':
            s['treeStableTimer'] = None
            s['fileIsImportant'] = DefaultGCCfileIsImportant
        elif s['type'] == 'Nightly':
            try:
                s['dayOfWeek'] = int (s['dayOfWeek'])
            except:
                pass
            try:
                s['hour'] = int (s['hour'])
            except:
                pass
            try:
                s['minute'] = int (s['minute'])
            except:
                pass
            s['onlyIfChanged'] = False
            s['branch'] = 'trunk'
        elif s['type'] == 'Try_Jobdir':
            s['properties']  = { 'isTrySched' : 'yes' }
        if "change_filter" in s:
            s['change_filter'] = globals ()[s['change_filter']]
        kls = globals ()[s.pop ('type')]
        d = dict (map (lambda key_value_pair : (str (key_value_pair[0]),
                                                key_value_pair[1]),
                       s.items ()))
        c['schedulers'].append (kls (**d))

    c['builders'] = []
    for b in config['builders']:
        myenv = {}

        if 'arch_triplet' in b:
            architecture_triplet = [ b.pop ('arch_triplet') ]
        else:
            architecture_triplet = []

        btype = b.pop ('type')
        factory = globals ()[ "RunTestGCC%s" % btype ]
        b['factory'] = factory (architecture_triplet = architecture_triplet)
        #b['canStartBuild'] = DefaultGCCCanStartBuild
        #b['mergeRequests'] = False

        ntags = [str (x) for x in b['tags']]
        b['tags'] = ntags

        # AIX hack.  Sigh...
        try:
            mypath = b.pop ('PATH')
            myenv['PATH'] = mypath
            b['env'] = myenv
        except KeyError:
            pass

        b['nextBuild'] = prioritizeTryBuilds

        c['builders'].append (b)

load_config (c)


#### Force Scheduler configuration
c['schedulers'].append(schedulers.ForceScheduler(
    name="force",
    builderNames=[ 'Fedora-x86_64-m64' ],

    codebases=[
                util.CodebaseParameter(
            "",
            name="Main repository",
            # will generate a combo box
            branches_to_watch=util.ChoiceStringParameter(name='branch',
                                                         choices=['trunk'],
                                                         default='trunk'),

            # will generate nothing in the form, but revision, repository,
            # and project are needed by buildbot scheduling system so we
            # need to pass a value ("")
            revision=util.FixedParameter(name="revision", default=""),
            repository=util.FixedParameter(name="repository", default=""),
            project=util.FixedParameter(name="project", default=""),
        ),
    ],

    reason=util.StringParameter(name='reason',
                                label='reason:',
                                required=True,
                                size=80),

    username=util.UserNameParameter(label='name <email@domain>:',
                                    required=True,
                                    size=80)
    ))

c['buildbotNetUsageData'] = 'full'

# DB configuration
c['db'] = {
    'db_url': "mysql://gcc-buildbot:eck90542@localhost/gcc_buildbot?max_idle=300"
    }
